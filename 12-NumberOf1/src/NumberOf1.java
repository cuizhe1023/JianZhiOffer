/**
 * @Author: cuizhe
 * @Date: 2019/2/25 19:41
 */
public class NumberOf1 {
    /**
     * 题目：
     * 输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。
     */

    /**
     * 思路：
     * 先判断整数二进制表示中最右边一位是不是 1。
     * 接着把输入的整数右移一位，此时原来处于从右边数起的第二位被移到了最右边，在判断是不是 1。
     * 这样每次移动一位，知道整个整数变为 0 为止。
     * 那么，现在问题就变成了怎么判断最右边的是不是 1。
     * 只需要将整个数与 1 进行与运算，看结果是不是 0 就知道了。
     * 以 5 为例，
     * 5 的二进制为  00000101
     * 与1进行与运算 00000001
     * 得到的结果是 1，则说明整数的二进制表示最右边一位是 1。
     * 接着进行右移。
     * 得到的数为         00000010，
     * 再次与 1 进行与运算  00000001，
     * 得到的结果为 0 。则说明整数的二进制表示最右边一位是 0。
     * 再次进行右移
     * 得到的数为         00000001，
     * 再次与 1 进行与运算  00000001，
     * 得到的结果为 1。则说明整数的二进制表示最右边一位是 1。
     * 再次进行右移
     * 得到的数为 0，而 0 的二进制表示都为0。此时就得到了整数二进制表示中 1 的个数。
     *
     * @param n 整数
     * @return 整数二进制表示中 1 的个数
     */
    public static int numberOf1(int n) {
        int count = 0;
        while (n!=0){
            if ((n&1)!=0){
                count++;
            }
            n = n >> 1;
        }
        return count;
    }

    /**
     * 但是上面的函数若输入一个负数，则会陷入死循环，
     * 以 -5 为例，在计算机中，负数是以补码的形式存储在计算机中的。
     * 5 的原码为：00000101
     * 5 的反码为：11111010
     * 5 的补码为：11111011
     * 因此，-5 的二进制表示为 11111011.
     * 不论正负，在不溢出的情况下：
     * 左移 n 位后的值 等于原值乘以 2 的 n 次方
     * 右移 n 位后的值 等于原值除以 2 的 n 次方
     * 现在将 -5 右移 2 位，得到的结果是 11111110。
     * 因为不管怎么移动，正负号不会发生改变。所以，负数右移左边一直都是在补 1，因此会发生死循环。
     *
     * 为了不避免死循环，我们可以不右移输入的数字 n，先把 n 与 1 做与运算，判断 n 的最低位是不是 1。
     * 接着把 1 左移一位得到 2，在和 n 做与运算。就能判断 n 的次低位是不是 1……
     * 这样反复位移，每次都能判断 n 的其中一位是不是 1。
     * 以 -5 为例：
     * -5 的补码为 11111011
     * 先与 1 做与运算
     *   11111011
     * & 00000001 得到 00000001，则最低位为 1。
     * 再将 1 左移一位，得到 2 与 11111011 做与运算
     *   11111011
     * & 00000010 得到 00000010，则次低位也为 1。
     * ……
     * 以此类推，得到最终结果。(此结果正负数都适用)
     *
     * @param n 整数
     * @return 整数二进制表示中1的个数
     */
    public static int numberOf1_2(int n){
        int count = 0;
        int flag = 1;
        while (flag!=0){
            if ((n & flag)!=0){
                count++;
            }
            flag = flag<<1;
        }
        return count;
    }

    /**
     * 接下来介绍一种特别的解法：
     * 还是以 -5 为例，
     * -5 的二进制表示为：1011， -5-1 得到的结果为 1010。
     * 以 12 为例
     * 12 的二进制表示为：1100，12-1 得到的结果为 1011。
     * 则，我们可以发现：
     * 把一个整数 -1 后，其最右位的 1 变为 0。如果它右边还有 0，则之后的 0 变为 1，而其左边保持不变。
     * -5 最右位的 1 是最后一位。减 1 后变为 1010 。最后一位变为 0。
     * 12 最右位的 1 是第二位。减 1 后变为 1010 。第二位变为 0，三四位变为 1。
     * 我们把整数和他减 1 后的结果做与运算。还是以 12 为例：1100 & 1011 = 1000。
     *
     * 总结一下就是：把一个整数减一后，在和原整数做与运算，会把该整数最右边的一个 1 变为 0。
     * 那么一个数的二进制表示中有多少个 1，就可以进行多少次这样的操作。
     *
     * @param n 整数
     * @return 整数二进制表示中1的个数
     */
    public static int numberOf1_3(int n){
        int count = 0;
        while (n!=0){
            n = n & (n-1);
            count++;
        }
        return count;
    }

    public static void main(String[] args) {
        System.out.println(numberOf1_3(-5));
    }
}
