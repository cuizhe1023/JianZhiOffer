/**
 * @Author: cuizhe
 * @Date: 2019/3/10 12:30
 */
public class NumberOf1Between1AndN {
    /**
     * 题目：
     * 求出1~13的整数中1出现的次数,
     * 并算出100~1300的整数中1出现的次数？
     * 为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。
     * ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
     */

    /**
     * 思路：
     * 每个数都遍历一遍，判断这里面有几个1
     *
     * @param n 1-n
     * @return 1的个数
     */
    public static int numberOf1Between1AndN_1(int n) {
        if (n<=0){
            return 0;
        }
        int count = 0;
        for (int i = 1; i <= n; i++) {
            count = numberfor1(i) + count;
        }
        return count;
    }

    private static int numberfor1(int n) {
        int count = 0;
        while (n!=0){
            count = (n%10==1)?count+1:count;
            n = n/10;
        }
        return count;
    }

    /**
     * 思路：
     * 采用编程之美上面提出的方法，设定整数点（如1、10、100等等）作为位置点i（对应 n 的各位、十位、百位等等），
     * 分别对每个数位上有多少包含 1 的点进行分析。
     * 根据设定的整数位置，对n进行分割，分为两部分，高位 n/i，低位 n%i
     * 以 2953 为例，（0-9中 1 出现一次）
     * 个位：
     * 在 1-2950 中有 295 个 10，就是 295 个 0-9，又因为个位数 3 > 1。
     * 所以，个位数上存在 295 + 1 = 296 个 1
     * 十位：
     * 在 1-2900 中有 29 个 100，十位数上 1 的个数就是 29 * 10 = 290.
     * 因为 5 > 1, 所以又有 10 个 1。因此，十位数上 1 的个数是 290 + 10 = 300.
     * 百位：
     * 在 1-2000 中有 2 个 1000，百位上 1 的个数就是 2*100 = 200。
     * 因为 9 > 1 ，因此又有 100 个 1。因此，百位上 1 的个数是 200 + 100 = 300.
     * 千位：
     * 在 1-2000 中，2 > 1，因此有 1 个 1000，所以。千位上 1 的个数是 1000。
     * 加起来 1000+300+300+296 = 1896。
     * 再举个例子，以 21913 为例。
     * 个位：
     * 在 1-21910 中有 2191 个 10，就是 2191 个 0-9，又因为个位数 3>1。
     * 所以，个位数上存在 2191 + 1 = 2192 个 1
     * 十位:
     * 在 1-21900 中有 219 个 100，因此十位上 1 的个数为 219 * 10 = 2190，
     * 剩下的数字是从 21900-21913，他最大的十位数字 1 = 1，这种情况就比较复杂了。
     * 他的十位肯定是包含 1 的，但不会包含全部的 1，也就是不会包含 10 个1，
     * 他包含 1 的数目与十位和个位有关，是因为个位是 3，因此，十位会出现 10,11,12,13出现四次
     * 所以，十位上存在 2190 + 3（个位上的数字） + 1 = 2194.
     *      这里说明一下，当某一位与需要查找的数相同的时候，需要通过后面的低位进行判断，
     *      比如说，这个21913，当十位是 1 的时候，与要查找的 1 相同，那么就不会出现 10 次 1 ，
     *      那么出现多少次呢？ 因为个位是 3，所以会出现 3 + 1 = 4次，为啥要+1 呢，因为有个0，
     *      十位会有 10,11,12,13 出现 4 次 1 .
     * 百位：
     * 在 1-21000 中有 21 个 1000 ，因此百位上 1 的个数为 21 * 100 = 2100，又因为百位上的 9 > 1,因此 1 又会出现 100 次
     * 所以，百位上存在 2100 + 100 = 2200 个 1
     * 千位：
     * 在 1-20000 中有 2 个 10000，因此千位上 1 的个数为 2 * 1000 = 2000，剩下的数字式从 20000-21913，
     * 这里就和十位的情况一样了，因为在千位之后是 913 ，因此千位还会有 913 个 1，在加上一个 1（这个1的情况是21000） ，
     * 所以，千位上存在 2000 + 913（低位上的数字） + 1 = 2914.
     * 万位：
     * 万位的 2 > 1，所以会有 10000 个 1，
     * 所以，万位上存在 10000 个1
     * 加起来 10000 + 2914 + 2200 + 2194 + 2192 = 19500.
     *
     * @param n 1-n
     * @return 1的个数
     */
    public static int numberOf1Between1AndN_2(int n){
        int count = 0;
        for (int i = 1; i <= n; i=i*10) {
            int a = n/i;//这个是高位
            int b = n%i;//这个是低位
            //之所以(a+8)是因为查的是 1 的个数，当该为 >= 2时，证明该位的1已经遍历完了，
            //比如 21913 的百位
            //在 1-21000 中有 21 个 1000 ，因此百位上 1 的个数为 21 * 100 = 2100
            //又因为百位的 9 > 1,证明百位的1遍历完了，即21100,21101,21102...21199遍历完了，这里有100个 1。
            //在计算的时候就需要把这 100 算进去
            //而(a+8)会产生进位，效果等同于(a/10+1),如果判断的不是 1 的个数，是别的数的话，进行相应的更改。
            count += (a+8)/10 * i + ((a%10==1)?b+1:0);
        }
        return count;
    }
    public static void main(String[] args) {
        System.out.println(numberOf1Between1AndN_2(21913));
    }
}
